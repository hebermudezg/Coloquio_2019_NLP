abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Modelo 2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(as.numeric(ythat2),et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Modelo 2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
#Gr?ficos de los residuales del modelo 1
### hold-winters
#win.graph()
plot(et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#win.graph()
plot(as.numeric(ythat.h),et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#
yt=ts(Datos16,freq=12,start=c(2003,1))
class(yt) # Clase del objeto
library(forecast); library(TSA); library(strucchange)
library(fANCOVA)
#Gr?fica de la serie y de su logaritmo natural
plot(yt)
#Creando funci?on para extraer correctamente los valores deltai
factoresdeltai=function(descom,s,estacionini){ if(estacionini==1){ deltasi=descom$figure }
if(estacionini!=1){ j=estacionini;deltasi=c(descom$figure[(s-j+2):s],descom$figure[1:(s-j+1)]) }
deltasi
}
#Creando funci?on usuario crit.inf.resid() para calcular C_n?*(p)
crit.inf.resid=function(residuales,n.par,AIC="TRUE")
{ if(AIC=="TRUE"){
#Calcula AIC
CI=log(mean(residuales^2))+2*n.par/length(residuales)
}
if(AIC=="FALSE"){
#Calcula BIC
CI=log(mean(residuales^2))+n.par*log(length(residuales))/length(residuales)
}
CI
}
#Funci?on para calcular la amplitud de los I.P
amplitud=function(LIP,LSP){
a=LSP-LIP
am=mean(a)
am
}
#Funci?on para calcular la cobertura de los I.P
cobertura=function(real,LIP,LSP){
I=ifelse(real>=LIP & real<=LSP,1,0)
p=mean(I)
p
}
yt=ts(Datos16,freq=12,start=c(2003,1))
#Para leer "Indices empalmados ventas nominales de la EMCM seg?n grupo de mercanc?a - Total nacionalp.csv" columna 19:  Otras mercanc?as para uso personal o dom?stico, no especificadas anteriormente
Datos16=read.table(file.choose(),header=T,sep=";",skip=8,dec=",",colClasses=c(rep("NULL",18),"numeric"))
yt=ts(Datos16,freq=12,start=c(2003,1))
class(yt) # Clase del objeto
library(forecast); library(TSA); library(strucchange)
library(fANCOVA)
library(forecast); library(TSA); library(strucchange)
library(fANCOVA)
#Gr?fica de la serie y de su logaritmo natural
plot(yt)
plot(log(yt))
#An?lisis descriptivo de la serie
#win.graph()
plot(decompose(yt,type="multiplicative")) #Descomp. multip. para la serie
plot(decompose())
#win.graph()
plot(decompose(log(yt),type="additive")) #Descomp. aditiva log(Datos16)
#Componente de la tendencia
Tt.log <- decompose(log(yt),type="additive")$trend     # ==
Tt.log=decompose(log(yt))$trend                        # ==
plot(Tt.log, main="Componente de tendencia estimada")
#win.graph()
plot(Tt.log,ylim=c(min(log(yt)),max(log(yt))),
main="Componente de tendencia estimada")
#Boxplots para comparar la distribuci?n de la serie seg?n periodo del a?o
boxplot(yt~cycle(yt), names(month.abb))
n=length(yt)-12
t=1:n
yt2=ts(yt[t],freq=12,start=c(2003,1)) #Valores de la serie para el ajuste
tnuevo=(n+1):length(yt) #?ndice de tiempo para pron?sticos en la validaci?n cruzada
ytf=ts(yt[tnuevo],freq=12,start=c(2017,7)) #valores de la serie en la validaci?n cruzada
#Eliminar tendencia aplicando primera diferencia
#Consideramos a log(Yt) pues la serie es multiplicativa
x=diff(log(yt))
#Gr?fica de la serie y primera diferencia sobre los logaritmos
#win.graph(width=10,height=5)
layout(cbind(c(1,1),c(2,2)))
plot(yt)
plot(x)
#Periodograma
#En el anterior periodograma se
#observa que en las frecuencias de la forma Fj = j/12,
#con j = 1,2,3,4,5,6 existen componentes peri?dicas claramente significativas para la serie
library(TSA)
#win.graph()
periodogram(x,lwd=3)
abline(h=0)
abline(v=c((1:6)/12),col=2,lty=2)
plot.ts(log(yt)[1:60],ylab=expression(log(yt)),
main="log(yt) - primeros 60 meses")
abline(v=seq(1,60,by=12),col=2)
layout(rbind(c(1,1,2,2),c(3,3,4,4)))
plot(log(yt))
plot(Tt.log,ylim=c(min(log(yt)),max(log(yt))),
main="Componente de tendencia estimada- log(yt)")
abline(v=seq(1,60,by=12),col=2)
boxplot(yt~cycle(yt), names(month.abb))
plot.ts(log(yt)[1:60],ylab=expression(log(yt)),
main="log(yt) - primeros 60 meses")
abline(v=seq(1,60,by=12),col=2)
win.graph()
par(mfrow=c(6,1))
plot(et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Modelo 1b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(as.numeric(ythat),et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Modelo 1b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Modelo 2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(as.numeric(ythat2),et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Modelo 2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
#Gr?ficos de los residuales del modelo 1
### hold-winters
#win.graph()
plot(et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#win.graph()
plot(as.numeric(ythat.h),et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#
#Descomposici?n multiplicativa de los primeros n datos
descom=decompose(yt2,type="multiplicative")
St=descom$seasonal #Componente estacional estimada seg?n el filtro
#win.graph()
plot(St, main="Componente estacional estimada\ncon el filtro de descomposición multiplicativa")
#Extrayendo las estimaciones de los factores estacionales
#calculados con el filtro de la descomposici?n
deltas_i=factoresdeltai(descom=descom,s=12,estacionini=1) #valor estimado de los s=12 factores estacionales
data.frame(deltas_i)
xtable(data.frame(deltas_i))
#C?lculo de los pron?sticos de la componente estacional
i=c(7,8,9,10,11,12,1,2,3,4,5,6) #identificando No. de la estaci?n para los m=12 per?odos de los pron?sticos (Jul-07 a Jun-08)
Stnuevo=Stnuevo=deltas_i[i] #Pron?stico de St asignando los deltai a los per?odos a pronosticar
Stnuevo=ts(Stnuevo,frequency=12,start=c(2017,7)) #convirtiendo en serie de tiempo al pron?stico de St
s=12 #longitud del per?odo estacional
#Serie desdestacionalizada
yt.adj=yt2/St
#  Gr?ficos comparando los diferentes Loees y el grados de sus polinomios
#win.graph(width=10,height=5)
layout(cbind(c(1,1,2,2),c(3,3,4,4)))
win.graph()
par(mfrow=c(2,3))
ajusteLoess=loess.as(t,yt.adj,degree=1,criterion="gcv",family="gaussian",plot=F)
summary(ajusteLoess)
Tt=ts(fitted(ajusteLoess),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS lineal
alfa.optim1=ajusteLoess$pars$span #guardando el valor ?ptimo del par?metro alfa con loess lineal
plot(yt.adj, main="1b")
lines(Tt,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS lineal"),col=c(1,2),lty=1)
ajusteLoess=loess.as(t,yt.adj,degree=2,criterion="gcv",family="gaussian",plot=F)
summary(ajusteLoess)
Tt=ts(fitted(ajusteLoess),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS lineal
alfa.optim2=ajusteLoess$pars$span #guardando el valor ?ptimo del par?metro alfa con loess lineal
#win.graph()
plot(yt.adj,main="2b")
lines(Tt,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS cuadrática"),col=c(1,2),lty=1)
ajusteLoess=loess.as(t,yt.adj,degree=1,criterion="aicc",family="gaussian",plot=F)
summary(ajusteLoess)
Tt=ts(fitted(ajusteLoess),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS lineal
alfa.optim3=ajusteLoess$pars$span #guardando el valor ?ptimo del par?metro alfa con loess lineal
plot(yt.adj, main="1")
lines(Tt,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS lineal"),col=c(1,2),lty=1)
ajusteLoess=loess.as(t,yt.adj,degree=2,criterion="aicc",family="gaussian",plot=F)
summary(ajusteLoess)
Tt=ts(fitted(ajusteLoess),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS lineal
alfa.optim4=ajusteLoess$pars$span #guardando el valor ?ptimo del par?metro alfa con loess lineal
plot(yt.adj,main="2")
lines(Tt,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS cuadrático"),col=c(1,2),lty=1)
plot(St)#, main="Componente estacional estimada\ncon el filtro de descomposición multiplicativa")
win.graph()
par(mfrow=c(1,2))
#### lineal gcv
ajusteLoess=loess.as(t,yt.adj,degree=1,criterion="gcv",family="gaussian",plot=F)
summary(ajusteLoess)
Tt=ts(fitted(ajusteLoess),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS lineal
alfa.optim=ajusteLoess$pars$span #guardando el valor ?ptimo del par?metro alfa con loess lineal
plot(yt.adj,main="Serie desestacionalizada y su ajuste LOESS lineal óptimo\ncriterio GCV")
lines(Tt,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS lineal"),col=c(1,2),lty=1)
## 1
#Pron?sticos de la tendencia por loess lineal ?ptimo
Ttnuevo1=predict(loess(yt.adj~t,span=alfa.optim1,degree=1,control=loess.control(surface="direct")),
data.frame(t=tnuevo))
Ttnuevo1=ts(Ttnuevo,freq=12,start=c(2017,7))#convirtiendo en serie de tiempo al pron?stico de Tt, loess lineal
t(t(Ttnuevo))
#Ajuste final de la serie seg?n modelo multiplicativo
ythat=Tt*St
#Graficando la serie y su ajuste
plot(yt,main="Serie real y su ajuste\npor descomposición & LOESS lineal")
Ttnuevo1=ts(Ttnuevo,freq=12,start=c(2017,7))#convirtiendo en serie de tiempo al pron?stico de Tt, loess lineal
## 1
#Pron?sticos de la tendencia por loess lineal ?ptimo
Ttnuevo1=predict(loess(yt.adj~t,span=alfa.optim1,degree=1,control=loess.control(surface="direct")),
data.frame(t=tnuevo))
Ttnuevo1=ts(Ttnuevo,freq=12,start=c(2017,7))#convirtiendo en serie de tiempo al pron?stico de Tt, loess lineal
t(t(Ttnuevo))
#Ajuste final de la serie seg?n modelo multiplicativo
ythat=Tt*St
#Graficando la serie y su ajuste
plot(yt,main="Serie real y su ajuste\npor descomposición & LOESS lineal")
lines(ythat,col=2)
legend("topleft",legend=c("Original","Ajustada"),col=c(1,2),lty=1)
#Pron?stico de la serie seg?n modelo multiplicativo
#Combinaci?n de la descomposici?n y loess lineal
ytpron=Ttnuevo*Stnuevo
ytpron
tablapron=cbind(Pron_Tt=Ttnuevo,Pron_St=Stnuevo,Pron_serie=ytpron) #Tabla con los pron?sticos por componente y
#de la serie
tablapron
#Calculando medidas de precisi?n de pron?sticos combinaci?n descomposici?n & loess lineal
accuracy(ytpron,ytf)
et=yt2-ythat #residuales de ajuste del modelo 1
df=n-(round(ajusteLoess$enp)+s-1) #Grados de libertad aproximados del ajuste total
MSE=sum(et^2)/df #MSE aproximado del ajuste total
MSE
#Gr?ficos de los residuales del modelo 1
plot(et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Residuos vs. t\nAjuste por descomposición & LOESS
lineal")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(as.numeric(ythat),et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Residuos vs. ajustados\nAjuste
por descomposición & LOESS lineal")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
#C?lculo AIC y BIC aproximados versi?n exp????????
p1=round(ajusteLoess$enp)+s-1 #n?mero aproximado de par?metros en ajuste descompos. & loess lineal
AIC1=exp(crit.inf.resid(residuales=et,n.par=p1));AIC1
BIC1=exp(crit.inf.resid(residuales=et,n.par=p1,AIC="FALSE")); BIC1
################################################################
### Loes Cuadrático##
#win.graph()
par(mfrow=c(1,2))
ajusteLoess2=loess.as(t,yt.adj,degree=2,criterion="gcv",family="gaussian",plot=F)
summary(ajusteLoess2)
Tt2=ts(fitted(ajusteLoess2),frequency=12,start=c(2003,1)) #Tendencia ajustada LOESS cuadr?tico
alfa.optim2=ajusteLoess2$pars$span #guardando el valor ?ptimo del par?metro alfa
summary(ajusteLoess2)
plot(yt.adj,main="Serie desestacionalizada y su ajuste LOESS cuadrático optimo\ncriterio GCV")
lines(Tt2,col=2)
legend("topleft",legend=c("Serie ajustada estacionalmente","Tendencia LOESS cuadrático"),col=c(1,2),lty=1)
#Pron?sticos de tendencia por loess cuadr?tico ?ptimo
Ttnuevo2=predict(loess(yt.adj~t,span=alfa.optim2,degree=2,control=loess.control(surface="direct")),data.frame(t=
tnuevo))
Ttnuevo2=ts(Ttnuevo2,freq=12,start=c(2017,7))#convirtiendo en serie de tiempo al pron?stico de Tt, loess
#cuadr?tico
Ttnuevo2
#Ajuste final de la serie seg?n modelo multiplicativo
ythat2=Tt2*St
#Graficando la serie y sus ajustes
plot(yt,main="Serie real y su ajuste\npor descomposici?n & LOESS cuadr?tico")
lines(ythat2,col=2)
legend("topleft",legend=c("Original","Ajustada"),col=c(1,2),lty=1)
#Pron?stico de la serie seg?n modelo multiplicativo
ytpron2=Ttnuevo2*Stnuevo
ytpron2
####### pronostico total
tablapron2=cbind(Pron_Tt=Ttnuevo2,Pron_St=Stnuevo,Pron_serie=ytpron2) #Tabla con los pron?sticos por componente
#y de la serie
tablapron2
#Calculando medidas de precisi?n de pron?sticos combinaci?n descomposici?n & loess cuadr?tico
accuracy(ytpron2,ytf)
et2=yt-ythat2 #residuales de ajuste del modelo 2
df2=n-(round(ajusteLoess2$enp)+s-1) #Grados de libertad aproximados del ajuste total
MSE2=sum(et2^2)/df2 #MSE aproximado del ajuste total; MSE2
plot(et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Residuos vs. t\nAjuste por descomposici?n &
LOESS cuadr?tico")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(as.numeric(ythat2),et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Residuos vs.
ajustados\nAjuste por descomposici?n & LOESS cuadr?tico")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Residuos vs. t\nAjuste por descomposici?n &
LOESS cuadr?tico")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(as.numeric(ythat2),et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="Residuos vs.
ajustados\nAjuste por descomposici?n & LOESS cuadr?tico")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
#C?lculo AIC y BIC aproximados versi?n exp????????
plot(et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
plot(as.numeric(ythat2),et2,ylim=c(min(-2*sqrt(MSE2),et2),max(2*sqrt(MSE2),et2)),main="2b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE2),2*sqrt(MSE2)),col=2)
#Gr?ficos de los residuales del modelo 1
plot(et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Residuos vs. t\nAjuste por descomposición & LOESS
lineal")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(as.numeric(ythat),et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="Residuos vs. ajustados\nAjuste
por descomposición & LOESS lineal")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="1b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
plot(as.numeric(ythat),et,ylim=c(min(-2*sqrt(MSE),et),max(2*sqrt(MSE),et)),main="1b")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE),2*sqrt(MSE)),col=2)
### hold-winters
#win.graph()
plot(et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#win.graph()
plot(as.numeric(ythat.h),et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
suaviza=HoltWinters(yt2,seasonal="multiplicative", gamma = 0.999999)
suaviza
s=23
ythat.h=fitted(suaviza)[,1] #valores ajustados. Ya tienen formato de serie de tiempo
et3=residuals(suaviza) #residuales. Ya tienen formato de serie de tiempo
#Calculando AIC y BIC usando exp(C*n(p))
aich=exp(crit.inf.resid(residuals(suaviza),n.par=5)) #n?umero de par?ametros es (s-1)+2=5
aich
bich=exp(crit.inf.resid(residuals(suaviza),n.par=5,AIC="FALSE"))
bich
df3=n-2*s-((s-1)+2)
MSE3=suaviza$SSE/df3 #MSE aproximado del ajuste total del Suavizamiento
MSE3
#GRAFICOS DE RESIDUALES MODELO 3
win.graph()
plot(et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Residuos vs. t\nAjuste por suavizamiento exponencial Holt-Winters")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#win.graph()
plot(as.numeric(ythat.h),et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Residuos vs. ajustados\nAjuste por suavizamiento exponencial Holt-Winters")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
plot(et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
#win.graph()
plot(as.numeric(ythat.h),et3,ylim=c(min(-2*sqrt(MSE3),et3),max(2*sqrt(MSE3),et3)),
main="Modelo 3")
abline(h=0,col=2)
abline(h=c(-2*sqrt(MSE3),2*sqrt(MSE3)),col=2)
summary(fit.1)
library(tidyverse)
squiggly <- function(x) sin(5 * x) / 200
eyes <- data_frame(x = c(-1, 1), y = 0.06)
mouth <- data_frame(x = 0, y = 0.04)
ggplot(mapping = aes(x = c(-10, 10))) +
geom_area(stat = "function", fun = squiggly, fill = "white") +
geom_area(stat = "function", fun = dnorm, fill = "white",
args = list(mean = 0, sd = 4)) +
geom_point(data = eyes, aes(x = x, y = y), size = 5) +
geom_point(data = mouth, aes(x = x, y = y), size = 15) +
labs(title = "Distribución Paranormal",
subtitle = "Por @JulioTellez, con código de @andrewheiss.") +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
library(tidyverse)
squiggly <- function(x) sin(5 * x) / 200
eyes <- data_frame(x = c(-1, 1), y = 0.06)
mouth <- data_frame(x = 0, y = 0.04)
ggplot(mapping = aes(x = c(-10, 10))) +
geom_area(stat = "function", fun = squiggly, fill = "white") +
geom_area(stat = "function", fun = dnorm, fill = "white",
args = list(mean = 0, sd = 4)) +
geom_point(data = eyes, aes(x = x, y = y), size = 5) +
geom_point(data = mouth, aes(x = x, y = y), size = 15) +
labs(title = "Distribución Paranormal",
subtitle = "Por @JulioTellez, con código de @andrewheiss.") +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
library(tidyverse)
squiggly <- function(x) sin(5 * x) / 200
eyes <- data_frame(x = c(-1, 1), y = 0.06)
mouth <- data_frame(x = 0, y = 0.04)
ggplot(mapping = aes(x = c(-10, 10))) +
geom_area(stat = "function", fun = squiggly, fill = "white") +
geom_area(stat = "function", fun = dnorm, fill = "white",
args = list(mean = 0, sd = 4)) +
geom_point(data = eyes, aes(x = x, y = y), size = 5) +
geom_point(data = mouth, aes(x = x, y = y), size = 15) +
labs(title = "Distribución Paranormal",
subtitle = "Por @JulioTellez, con código de @andrewheiss.") +
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
setwd("D:/National-University-of-Colombia/Coloquio_2019_NLP/Summarizer")
data<- read.csv("data_1000.csv")
view(data)
data<- read.csv("data_1000.csv")
View(data)
subdata <- data[1:400,]
text1 <- paste(subdata[,'Text'], collapse = ' °!"#$%&/()=?¡ ')
text1
write.table(text1, file = "text_400.txt", row.names = FALSE)
summarize <- paste(subdata[,'Summary'],collapse = ' °!"#$%&/()=?¡ ')
write.table(summarize, file = "sum_400.txt",row.names = FALSE)
archivo <- "text_400_trad.txt"
con <- file(archivo, open="r") # Abrimos la conexión
text_trad <- readLines(con)
text_trad
#================
Text<- as.data.frame(strsplit(text_trad, " Jijueputa "),col.names = F)
Text
View(Text)
summarize <- paste(subdata[,'Summary'],collapse = ' Jijueputa ')
write.table(summarize, file = "sum_400.txt",row.names = FALSE)
archivo <- "sum_400_trad.txt"
archivo2 <- "sum_400_trad.txt"
archivo <- "text_400_trad.txt"
con <- file(archivo, open="r") # Abrimos la conexión
text_trad <- readLines(con)
#================
Text<- as.data.frame(strsplit(text_trad, " Jijueputa "),col.names = F)
View(Text)
archivo2 <- "sum_400_trad.txt"
con <- file(archivo2, open="r") # Abrimos la conexión
sum_trad <- readLines(con)
archivo2 <- "sum_400_trad.txt"
con <- file(archivo2, open="r") # Abrimos la conexión
sum_trad <- readLines(con)
summ<- as.data.frame(strsplit(sum_trad, " Jijueputa "),col.names = F)
View(summa)
View(summ)
archivo2 <- "sum_400_trad2.txt.txt"
con <- file(archivo2, open="r") # Abrimos la conexión
sum_trad <- readLines(con)
summ<- as.data.frame(strsplit(sum_trad, " Catretriplejijueputa "),col.names = F)
View(summ)
archivo2 <- "catre.txt"
con <- file(archivo2, open="r") # Abrimos la conexión
sum_trad <- readLines(con)
summ<- as.data.frame(strsplit(sum_trad, " Catretriplejijueputa "),col.names = F)
View(summ)
View(summ)
data_trad_400<- data.frame(Text, Summary, col.names = F)
data_trad_400<- rbind(Text, Summary)
Text
Summary[,2]
data_trad_400<- data.frame(Text, summ)
View(data_trad_400)
data_trad_400<- data.frame(Summary=summ, Text=Text)
View(data_trad_400)
data_trad_400<- data.frame(summ, Text)
data_trad_400<- colnames(c("Summary","Text")
data_trad_400<- colnames(c("Summary","Text"))
View(data_trad_400)
colnames(data_trad_400) <- c("Summary","Text"))
View(data_trad_400)
colnames(data_trad_400) <- c("Summary","Text")
View(data_trad_400)
save(file = data_trad_400.csv)
write.csv(file = data_trad_400.csv)
write.csv(x = data_trad_400, file = "data_trad_400.csv")
install.packages("translateR")
library(translateR)
res <- translate(content.vec = c("Hello world.", "This is a test."),
microsoft.client.id = "foo_id",
microsoft.client.secret = "fdsg54345_bar_secret_560985lkfdasd",
source.lang = "en",
target.lang = "de")
res
google.vector.out <- translate(content.vec = c("hello"),
google.api.key ="7b1ef338741601b76e982db9a4c0e9bd602071ed",
source.lang = 'en',
target.lang = 'es')
google.vector.out
translate??
help(tanslate)
help(translate)
install.packages("google-cloud-translate")
install.packages("translate")
